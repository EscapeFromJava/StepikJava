//Вам дан список ролей и сценарий пьесы в виде массива строчек.
//
//Каждая строчка сценария пьесы дана в следующем виде:
//Роль: текст
//
//Текст может содержать любые символы.
//
//Напишите метод, который будет группировать строчки по ролям, пронумеровывать их и возвращать результат в виде готового текста (см. пример). Каждая группа распечатывается в следующем виде:
//
//Роль:
//i) текст
//j) текст2
//...
//==перевод строки==
//
//i и j -- номера строк в сценарии. Индексация строчек начинается с единицы, выводить группы следует в соответствии с порядком ролей. Переводы строк между группами обязательны, переводы строк в конце текста не учитываются.
//
//Заметим, что вам предстоит обработка огромной пьесы в 50 000 строк для 10 ролей – соответственно, неправильная сборка результирующей строчки может выйти за ограничение по времени.
//
//Обратите внимание еще на несколько нюансов:
//
//имя персонажа может встречаться в строке более одного раза, в том числе с двоеточием;
//название одной роли может быть префиксом названия другой роли (например, "Лука" и "Лука Лукич");
//роль, у которой нет реплик, тоже должна присутствовать в выходном файле;
//в качестве перевода строки надо использовать символ '\n' (перевод строки в стиле UNIX);
//будьте внимательны, не добавляйте лишних пробелов в конце строк.
//Sample Input:
//
//roles:
//Городничий
//Аммос Федорович
//Артемий Филиппович
//Лука Лукич
//textLines:
//Городничий: Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.
//Аммос Федорович: Как ревизор?
//Артемий Филиппович: Как ревизор?
//Городничий: Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.
//Аммос Федорович: Вот те на!
//Артемий Филиппович: Вот не было заботы, так подай!
//Лука Лукич: Господи боже! еще и с секретным предписаньем!
//Sample Output:
//
//Городничий:
//1) Я пригласил вас, господа, с тем, чтобы сообщить вам пренеприятное известие: к нам едет ревизор.
//4) Ревизор из Петербурга, инкогнито. И еще с секретным предписаньем.
//
//Аммос Федорович:
//2) Как ревизор?
//5) Вот те на!
//
//Артемий Филиппович:
//3) Как ревизор?
//6) Вот не было заботы, так подай!
//
//Лука Лукич:
//7) Господи боже! еще и с секретным предписаньем!

package org.example.section_2._4;

import java.util.ArrayList;
import java.util.LinkedHashMap;

public class Task_2_4_3 {
    private String printTextPerRoleVar1(String[] roles, String[] textLines) {
        StringBuilder text = new StringBuilder();
        for (String role : roles) {
            text.append(role.concat(":\n"));
            for (int i = 0; i < textLines.length; i++) {
                if (textLines[i].startsWith(role.concat(":"))) {
                    text.append(i+1);
                    text.append(")".concat(textLines[i].substring( textLines[i].indexOf(":")+ 1)).concat("\n"));
                }
            }
            text.append("\n");
        }
        return String.valueOf(text);
    }

    private static String printTextPerRoleVar2(String[] roles, String[] textLines) {
        LinkedHashMap<String, ArrayList<String>> linkedHashMap = new LinkedHashMap<>();
        for (String role : roles) {
            linkedHashMap.put(role, new ArrayList<>());
        }

        for (int i = 0; i < textLines.length; i++) {
            int indexChar = textLines[i].indexOf(':');
            String currentRole = textLines[i].substring(0, indexChar).split(" ")[0];
            String currentActor = linkedHashMap.keySet().stream().filter(el -> el.contains(currentRole)).findFirst().get();
            String currentText = textLines[i].substring(indexChar + 1).trim();
            linkedHashMap.get(currentActor).add((i + 1) + ") " + currentText);
        }

        StringBuilder text = new StringBuilder();
        for (String role : linkedHashMap.keySet()) {
            text.append(role.concat(":\n"));
            for (String roleText : linkedHashMap.get(role)) {
                text.append(roleText.concat("\n"));
            }
            text.append("\n");
        }
        return String.valueOf(text);
    }
}
